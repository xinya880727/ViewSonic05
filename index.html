<!DOCTYPE html>
<html lang="zh-Hant">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>è¿·å®®é€ƒè„« - è‡ªè¨‚åƒæ•¸ç‰ˆ</title>
    
    <!-- å¼•å…¥å¤–éƒ¨è¨­å®šæª” -->
    <script src="game_config.js"></script>

    <style>
        * {
            box-sizing: border-box;
            touch-action: none;
        }

        body {
            margin: 0;
            padding: 0;
            background-color: #1a1a1a;
            color: #ecf0f1;
            font-family: 'Segoe UI', 'Microsoft JhengHei', sans-serif;
            overflow: hidden;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            height: 100vh;
            background-image: radial-gradient(circle at center, #2c3e50 0%, #000000 100%);
            background-size: cover;
            background-position: center;
        }

        #game-container {
            position: relative;
            border-radius: 12px;
            overflow: hidden;
            background: transparent;
            z-index: 1; 
        }

        canvas {
            display: block;
            cursor: crosshair;
        }

        /* UI è¦†è“‹å±¤ - å…¨è¢å¹• */
        #ui-layer {
            position: fixed;
            top: 0;
            left: 0;
            width: 100vw;
            height: 100vh;
            background: transparent;
            background-size: cover;
            background-position: center;
            
            /* ä¿®æ­£ï¼šæ¢å¾© flex ä½ˆå±€ä½œç‚ºé è¨­å€¼ï¼Œä»¥é˜²æŸäº›å…ƒç´ æ²’æœ‰è¨­å®šçµ•å°å®šä½æ™‚æœƒè·‘ç‰ˆ */
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            gap: 20px; /* å¢åŠ é–“è·ï¼Œè®“æ²’æœ‰å®šä½çš„å…ƒç´ ä¸æœƒé»åœ¨ä¸€èµ· */
            
            z-index: 999;
            padding: 0;
            transition: background-color 0.5s ease, opacity 0.3s ease;
            pointer-events: auto;
        }

        #ui-layer.hidden {
            opacity: 0;
            pointer-events: none;
        }

        /* é è¨­æ¨£å¼ï¼Œæœƒè¢« JS è¨­å®šè¦†è“‹ */
        h1, p, button {
            position: relative;
            margin: 0;
            text-align: center;
            white-space: nowrap; /* é˜²æ­¢æ–‡å­—æ›è¡Œå½±éŸ¿å®šä½ */
        }

        h1 {
            font-size: 2.5rem;
            color: #f1c40f;
            text-transform: uppercase;
            letter-spacing: 3px;
            text-shadow: 0 0 10px rgba(241, 196, 15, 0.5);
        }

        p {
            font-size: 1.1rem;
            line-height: 1.6;
            color: #bdc3c7;
            text-shadow: 1px 1px 2px rgba(0,0,0,0.8);
        }

        button {
            background: linear-gradient(135deg, #e74c3c 0%, #c0392b 100%);
            color: white;
            border: none;
            padding: 15px 40px;
            font-size: 1.3rem;
            border-radius: 8px;
            cursor: pointer;
            box-shadow: 0 5px 15px rgba(192, 57, 43, 0.4);
            transition: all 0.2s ease;
            font-weight: bold;
            letter-spacing: 1px;
            text-transform: uppercase;
        }

        button:hover {
            transform: translateX(-50%) translateY(-2px); /* å‡è¨­æœ‰ç½®ä¸­ï¼Œè‹¥ç„¡å‰‡ JS æœƒè¦†å¯« */
            filter: brightness(1.1);
        }

        button:active {
            transform: translateX(-50%) translateY(2px);
            filter: brightness(0.9);
        }

        /* ç°¡å–®çš„æŒ‰éˆ• hover ä¿®æ­£ï¼Œé‡å°æœªå®šä½çš„æƒ…æ³ */
        button:not([style*="absolute"]):hover {
             transform: translateY(-2px);
        }

        #info-bar {
            position: fixed;
            top: 20px;
            left: 20px;
            color: rgba(255, 255, 255, 0.9);
            font-family: monospace;
            font-size: 18px;
            z-index: 100;
            pointer-events: none;
            background: rgba(0, 0, 0, 0.3);
            padding: 8px 15px;
            border-radius: 4px;
            border: 1px solid rgba(255,255,255,0.1);
        }

        #debug {
            position: absolute;
            bottom: 5px;
            left: 5px;
            font-size: 10px;
            color: #555;
            pointer-events: none;
        }
    </style>
</head>
<body>

    <div id="info-bar">TIME: <span id="time-display">0.0</span>s</div>

    <!-- UI Layer -->
    <div id="ui-layer">
        <h1 id="game-title">è¿·å®®é€ƒè„«</h1>
        <p id="ui-message">...</p>
        <button id="start-btn">...</button>
    </div>

    <div id="game-container">
        <canvas id="mazeCanvas"></canvas>
        <div id="debug"></div>
    </div>

    <script>
        // ==========================================
        //        ğŸš€ éŠæˆ²æ ¸å¿ƒé‚è¼¯
        // ==========================================

        // --- 1. è¨­å®šæª”è®€å– ---
        let currentConfig;
        
        // é è¨­è¨­å®š
        const DEFAULT_CONFIG = {
            scale: { player: 0.7, goal: 0.8 },
            physics: { cellSize: 50, ballRadiusRatio: 0.35, friction: 0.94, acceleration: 0.6, maxSpeed: 12, keyboardForce: 1.5 },
            assets: { gameBg: "", startScreenBg: "", endScreenBg: "", player: "", goal: "" },
            style: { wallColor: "#7f8c8d", wallGlow: true, wallThickness: 4, playerColor: "#e74c3c", goalColor: "#2ecc71" },
            text: { gameTitle: "è¿·å®®é€ƒè„«", winTitle: "é€ƒè„«æˆåŠŸï¼", startMessage: "...", startButton: "é–‹å§‹", winMessage: "å‹åˆ©ï¼", nextLevelButton: "é‡è©¦" },
            // é è¨­æ–‡å­—æ¨£å¼
            textStyle: {
                title: { color: "#f1c40f", size: "2.5rem", shadow: "0 0 10px rgba(241, 196, 15, 0.5)", position: { top: "15%", left: "50%" } },
                winTitle: { color: "#2ecc71", size: "3rem", shadow: "0 0 20px rgba(46, 204, 113, 0.8)", position: { top: "20%", left: "50%" } },
                message: { color: "#bdc3c7", size: "1.1rem", shadow: "1px 1px 2px rgba(0,0,0,0.8)", position: { top: "40%", left: "50%" } },
                winMessage: { color: "#ffffff", size: "1.5rem", shadow: "0 0 10px rgba(255, 255, 255, 0.8)", position: { top: "45%", left: "50%" } },
                button: { 
                    color: "#ffffff", 
                    bgColor: "linear-gradient(135deg, #e74c3c 0%, #c0392b 100%)",
                    size: "1.3rem", 
                    shadow: "0 5px 15px rgba(192, 57, 43, 0.4)",
                    position: { bottom: "20%", left: "50%" }
                }
            }
        };

        if (typeof window.GAME_CONFIG !== 'undefined') {
            currentConfig = window.GAME_CONFIG;
            
            // --- é˜²å‘†æ©Ÿåˆ¶è£œå¼· ---
            // ç¢ºä¿ textStyle çµæ§‹å­˜åœ¨
            if (!currentConfig.textStyle) currentConfig.textStyle = JSON.parse(JSON.stringify(DEFAULT_CONFIG.textStyle));

            // ç¢ºä¿å¿…è¦çš„æ–‡å­—æ¬„ä½å­˜åœ¨
            if (!currentConfig.text.winTitle) currentConfig.text.winTitle = DEFAULT_CONFIG.text.winTitle;

            // æª¢æŸ¥æ¯å€‹å…ƒä»¶çš„ positionï¼Œå¦‚æœç¼ºå¤±å‰‡è£œä¸Šé è¨­å€¼
            ['title', 'winTitle', 'message', 'winMessage', 'button'].forEach(key => {
                if (!currentConfig.textStyle[key]) {
                    currentConfig.textStyle[key] = DEFAULT_CONFIG.textStyle[key];
                } else if (!currentConfig.textStyle[key].position) {
                    currentConfig.textStyle[key].position = DEFAULT_CONFIG.textStyle[key].position;
                }
            });

        } else {
            console.warn("âš ï¸ è­¦å‘Šï¼šç„¡æ³•è®€å– game_config.jsã€‚ä½¿ç”¨é è¨­æ¨¡å¼ã€‚");
            currentConfig = DEFAULT_CONFIG;
        }

        const THEME = currentConfig.assets;
        Object.assign(THEME, currentConfig.style);
        Object.assign(THEME, currentConfig.text);
        const CONFIG = currentConfig.physics;
        const SCALE = currentConfig.scale;
        const TEXT_STYLE = currentConfig.textStyle;

        // --- 2. æ‡‰ç”¨è¨­å®šåˆ°ä»‹é¢ ---
        
        const titleEl = document.getElementById('game-title');
        const msgEl = document.getElementById('ui-message');
        const btnEl = document.getElementById('start-btn');

        // åˆå§‹åŒ–é–‹å§‹ç•«é¢
        function resetStartScreen() {
            titleEl.innerText = THEME.gameTitle;
            msgEl.innerHTML = THEME.startMessage;
            btnEl.innerText = THEME.startButton;
            
            applyStyle(titleEl, TEXT_STYLE.title);
            applyStyle(msgEl, TEXT_STYLE.message);
            applyStyle(btnEl, TEXT_STYLE.button, true);
        }

        // å¥—ç”¨æ¨£å¼èˆ‡ä½ç½®
        function applyStyle(element, styleObj, isButton = false) {
            if (!element || !styleObj) return;
            
            // å¤–è§€
            if (styleObj.color) element.style.color = styleObj.color;
            if (styleObj.size) element.style.fontSize = styleObj.size;
            if (styleObj.bgColor) element.style.background = styleObj.bgColor;
            
            if (styleObj.shadow) {
                if (isButton) {
                    element.style.boxShadow = styleObj.shadow;
                } else {
                    element.style.textShadow = styleObj.shadow;
                }
            }

            // ä½ç½® (Position)
            element.style.position = ""; 
            element.style.top = "";
            element.style.bottom = "";
            element.style.left = "";
            element.style.right = "";
            element.style.transform = "";

            if (styleObj.position) {
                element.style.position = "absolute"; 
                const pos = styleObj.position;
                
                if (pos.top !== undefined) element.style.top = pos.top;
                if (pos.bottom !== undefined) element.style.bottom = pos.bottom;
                if (pos.left !== undefined) element.style.left = pos.left;
                if (pos.right !== undefined) element.style.right = pos.right;

                if (pos.left === "50%") {
                    element.style.transform = "translateX(-50%)";
                }
            }
        }

        // åŸ·è¡Œåˆå§‹åŒ–
        resetStartScreen();


        // --- è®Šæ•¸å®£å‘Š ---
        const canvas = document.getElementById('mazeCanvas');
        const ctx = canvas.getContext('2d');
        const uiLayer = document.getElementById('ui-layer');
        const timeDisplay = document.getElementById('time-display');

        let mazeState = {};
        let cols, rows;
        let ball = { x: 0, y: 0, vx: 0, vy: 0, radius: 0 };
        let goal = { col: 0, row: 0 };
        let animationId;
        let lastTime = 0;
        let timer = 0;
        let isPlaying = false;
        let input = { x: 0, y: 0 };

        // --- åœ–ç‰‡è¼‰å…¥ç³»çµ± ---
        const sprites = {
            bg: new Image(), 
            startBg: new Image(),
            endBg: new Image(),
            player: new Image(),
            goal: new Image()
        };
        let assetsLoaded = { bg: false, startBg: false, endBg: false, player: false, goal: false };

        function loadAssets() {
            if (THEME.gameBg) {
                document.body.style.backgroundImage = `url('${THEME.gameBg}')`;
            }

            if (THEME.startScreenBg) {
                sprites.startBg.src = THEME.startScreenBg;
                sprites.startBg.onload = () => {
                    assetsLoaded.startBg = true;
                    if(!isPlaying && !uiLayer.classList.contains('hidden')) {
                        uiLayer.style.backgroundImage = `url('${THEME.startScreenBg}')`;
                    }
                };
            }

            if (THEME.endScreenBg) {
                sprites.endBg.src = THEME.endScreenBg;
                sprites.endBg.onload = () => assetsLoaded.endBg = true;
            }

            if (THEME.player) {
                sprites.player.src = THEME.player;
                sprites.player.onload = () => assetsLoaded.player = true;
            }
            if (THEME.goal) {
                sprites.goal.src = THEME.goal;
                sprites.goal.onload = () => assetsLoaded.goal = true;
            }
        }

        // --- åˆå§‹åŒ– ---
        function initGame() {
            resizeCanvas();
            uiLayer.style.backgroundImage = "none";
            uiLayer.style.backgroundColor = "transparent";

            const mazePadding = 25; 
            const availableWidth = canvas.width - (mazePadding * 2);
            const availableHeight = canvas.height - (mazePadding * 2);

            cols = Math.floor(availableWidth / CONFIG.cellSize);
            rows = Math.floor(availableHeight / CONFIG.cellSize);
            
            if (cols < 3) cols = 3;
            if (rows < 3) rows = 3;

            const effectiveCellWidth = availableWidth / cols;
            const effectiveCellHeight = availableHeight / rows;
            const finalSize = Math.min(effectiveCellWidth, effectiveCellHeight);
            
            const offsetX = (canvas.width - cols * finalSize) / 2;
            const offsetY = (canvas.height - rows * finalSize) / 2;

            mazeState = {
                cols: cols,
                rows: rows,
                cellSize: finalSize,
                offsetX: offsetX,
                offsetY: offsetY,
                grid: []
            };

            generateMaze();
            spawnBallAndGoal();
            
            timer = 0;
            ball.vx = 0;
            ball.vy = 0;
            isPlaying = true;
            lastTime = performance.now();
            
            if (animationId) cancelAnimationFrame(animationId);
            gameLoop(lastTime);
        }

        // --- è¿·å®®ç”Ÿæˆ ---
        function generateMaze() {
            mazeState.grid = [];
            for (let r = 0; r < rows; r++) {
                let row = [];
                for (let c = 0; c < cols; c++) {
                    row.push({
                        c: c, r: r, visited: false,
                        walls: { top: true, right: true, bottom: true, left: true }
                    });
                }
                mazeState.grid.push(row);
            }

            let stack = [];
            let current = mazeState.grid[0][0];
            current.visited = true;
            stack.push(current);

            while (stack.length > 0) {
                let next = checkNeighbors(current);
                if (next) {
                    next.visited = true;
                    stack.push(current);
                    removeWalls(current, next);
                    current = next;
                } else {
                    current = stack.pop();
                }
            }
        }

        function checkNeighbors(cell) {
            let neighbors = [];
            let top = (cell.r > 0) ? mazeState.grid[cell.r - 1][cell.c] : undefined;
            let right = (cell.c < cols - 1) ? mazeState.grid[cell.r][cell.c + 1] : undefined;
            let bottom = (cell.r < rows - 1) ? mazeState.grid[cell.r + 1][cell.c] : undefined;
            let left = (cell.c > 0) ? mazeState.grid[cell.r][cell.c - 1] : undefined;

            if (top && !top.visited) neighbors.push(top);
            if (right && !right.visited) neighbors.push(right);
            if (bottom && !bottom.visited) neighbors.push(bottom);
            if (left && !left.visited) neighbors.push(left);

            if (neighbors.length > 0) {
                return neighbors[Math.floor(Math.random() * neighbors.length)];
            }
            return undefined;
        }

        function removeWalls(a, b) {
            let x = a.c - b.c;
            if (x === 1) { a.walls.left = false; b.walls.right = false; }
            else if (x === -1) { a.walls.right = false; b.walls.left = false; }
            let y = a.r - b.r;
            if (y === 1) { a.walls.top = false; b.walls.bottom = false; }
            else if (y === -1) { a.walls.bottom = false; b.walls.top = false; }
        }

        // --- å¯¦é«”ç”Ÿæˆ ---
        function spawnBallAndGoal() {
            let size = mazeState.cellSize;
            ball.radius = size * CONFIG.ballRadiusRatio;
            ball.x = mazeState.offsetX + size * 0.5;
            ball.y = mazeState.offsetY + size * 0.5;
            
            goal.col = cols - 1;
            goal.row = rows - 1;
        }

        // --- ç‰©ç†æ›´æ–° (ä¿®æ”¹ï¼šå¾åŠ é€Ÿåº¦æ”¹ç‚ºç›´æ¥é€Ÿåº¦æ§åˆ¶) ---
        function update(dt) {
            if (!isPlaying) return;
            timer += dt / 1000;
            timeDisplay.innerText = timer.toFixed(1);

            // [ä¿®æ”¹é‡é»] è®“è§’è‰²é€Ÿåº¦ç›´æ¥åæ‡‰å‚¾æ–œåº¦ï¼Œä¸å†ç´¯åŠ åŠ é€Ÿåº¦
            // é€™æœƒè§£æ±º "æ„Ÿè¦ºåƒåœ¨å†°ä¸Šæ»‘" æˆ– "æ²’è¾¦æ³•å³æ™‚åœä¸‹" çš„å•é¡Œ
            
            // 1. è¨ˆç®—ç›®æ¨™é€Ÿåº¦ (å‚¾æ–œè¶Šå¤šï¼Œé€Ÿåº¦è¶Šå¿«)
            const targetVx = input.x * CONFIG.maxSpeed;
            const targetVy = input.y * CONFIG.maxSpeed;

            // 2. ä½¿ç”¨å¹³æ»‘ç§»å‹• (Lerp)ï¼Œä¿‚æ•¸ 0.2 ä»£è¡¨åæ‡‰å¾ˆéˆæ• (æ•¸å€¼è¶Šå¤§è¶Šå¿«)
            ball.vx += (targetVx - ball.vx) * 0.2;
            ball.vy += (targetVy - ball.vy) * 0.2;

            // æ³¨æ„ï¼šæˆ‘å€‘ç§»é™¤äº† friction ä¹˜æ³•ï¼Œå› ç‚ºç¾åœ¨é€Ÿåº¦æ˜¯ç›´æ¥æ§åˆ¶çš„

            let nextX = ball.x + ball.vx;
            let nextY = ball.y + ball.vy;
            let size = mazeState.cellSize;
            let ox = mazeState.offsetX;
            let oy = mazeState.offsetY;

            let currentC = Math.floor((ball.x - ox) / size);
            let currentR = Math.floor((ball.y - oy) / size);
            
            currentC = Math.max(0, Math.min(cols - 1, currentC));
            currentR = Math.max(0, Math.min(rows - 1, currentR));

            let cell = mazeState.grid[currentR][currentC];

            if (cell.walls.left && nextX - ball.radius < ox + currentC * size) {
                nextX = ox + currentC * size + ball.radius;
                ball.vx = -ball.vx * 0.4; // æ’ç‰†åå½ˆæ¸›é€Ÿ
            } else if (cell.walls.right && nextX + ball.radius > ox + (currentC + 1) * size) {
                nextX = ox + (currentC + 1) * size - ball.radius;
                ball.vx = -ball.vx * 0.4;
            }
            ball.x = nextX;

            if (cell.walls.top && nextY - ball.radius < oy + currentR * size) {
                nextY = oy + currentR * size + ball.radius;
                ball.vy = -ball.vy * 0.4;
            } else if (cell.walls.bottom && nextY + ball.radius > oy + (currentR + 1) * size) {
                nextY = oy + (currentR + 1) * size - ball.radius;
                ball.vy = -ball.vy * 0.4;
            }
            ball.y = nextY;

            let goalX = ox + goal.col * size + size * 0.5;
            let goalY = oy + goal.row * size + size * 0.5;
            let dist = Math.sqrt((ball.x - goalX)**2 + (ball.y - goalY)**2);

            if (dist < size * 0.4) {
                winLevel();
            }
        }

        function winLevel() {
            isPlaying = false;
            let msg = THEME.winMessage.replace('{time}', timer.toFixed(2));
            msgEl.innerHTML = msg;
            btnEl.innerText = THEME.nextLevelButton;
            uiLayer.classList.remove('hidden');

            uiLayer.style.backgroundColor = "rgba(0, 0, 0, 0.85)";

            // 1. ä¿®æ”¹æ¨™é¡Œæ–‡å­—ç‚ºã€Œå‹åˆ©æ¨™é¡Œã€
            if (THEME.winTitle) {
                titleEl.innerText = THEME.winTitle;
            }
            
            // 2. å¥—ç”¨ã€Œå‹åˆ©æ¨™é¡Œã€æ¨£å¼
            if (TEXT_STYLE.winTitle) {
                applyStyle(titleEl, TEXT_STYLE.winTitle);
            }

            // 3. å¥—ç”¨ã€Œå‹åˆ©è¨Šæ¯ã€æ¨£å¼
            if (TEXT_STYLE.winMessage) {
                applyStyle(msgEl, TEXT_STYLE.winMessage);
            }

            if (assetsLoaded.endBg) {
                uiLayer.style.backgroundImage = `url('${THEME.endScreenBg}')`;
            }
        }

        // --- ç¹ªåœ– ---
        function draw() {
            ctx.clearRect(0, 0, canvas.width, canvas.height);

            let size = mazeState.cellSize;
            let ox = mazeState.offsetX;
            let oy = mazeState.offsetY;
            let goalX = ox + goal.col * size + size * 0.5;
            let goalY = oy + goal.row * size + size * 0.5;

            // 1. ç¹ªè£½çµ‚é»
            if (assetsLoaded.goal) {
                let goalSize = size * SCALE.goal;
                ctx.drawImage(sprites.goal, goalX - goalSize/2, goalY - goalSize/2, goalSize, goalSize);
            } else {
                ctx.shadowBlur = 20;
                ctx.shadowColor = THEME.goalColor;
                
                ctx.beginPath();
                ctx.arc(goalX, goalY, ball.radius * 1.2, 0, Math.PI * 2);
                ctx.fillStyle = THEME.goalColor; 
                ctx.fill();
                
                ctx.shadowBlur = 0;
                ctx.fillStyle = "#000";
                ctx.beginPath();
                ctx.arc(goalX, goalY, ball.radius * 0.8, 0, Math.PI * 2);
                ctx.fill();
                
                ctx.strokeStyle = THEME.goalColor;
                ctx.lineWidth = 2;
                ctx.beginPath();
                for(let i=0; i<3; i++) {
                     ctx.arc(goalX, goalY, ball.radius * (0.2 + i*0.2), 0 + timer*2, Math.PI + timer*2);
                }
                ctx.stroke();
            }

            // 2. ç¹ªè£½ç‰†å£
            ctx.strokeStyle = THEME.wallColor;
            ctx.lineWidth = THEME.wallThickness;
            ctx.lineCap = "round";
            
            if (THEME.wallGlow) {
                ctx.shadowBlur = 10;
                ctx.shadowColor = THEME.wallColor;
            } else {
                ctx.shadowBlur = 0;
            }

            ctx.beginPath();
            for (let r = 0; r < rows; r++) {
                for (let c = 0; c < cols; c++) {
                    let cell = mazeState.grid[r][c];
                    let x = ox + c * size;
                    let y = oy + r * size;

                    if (cell.walls.top) { ctx.moveTo(x, y); ctx.lineTo(x + size, y); }
                    if (cell.walls.right) { ctx.moveTo(x + size, y); ctx.lineTo(x + size, y + size); }
                    if (cell.walls.bottom) { ctx.moveTo(x + size, y + size); ctx.lineTo(x, y + size); }
                    if (cell.walls.left) { ctx.moveTo(x, y + size); ctx.lineTo(x, y); }
                }
            }
            ctx.stroke();
            ctx.shadowBlur = 0; 

            // 3. ç¹ªè£½ä¸»è§’
            if (assetsLoaded.player) {
                let pSize = size * SCALE.player; 
                ctx.drawImage(sprites.player, ball.x - pSize/2, ball.y - pSize/2, pSize, pSize);
            } else {
                ctx.shadowBlur = 15;
                ctx.shadowColor = THEME.playerColor;
                
                ctx.beginPath();
                ctx.arc(ball.x, ball.y, ball.radius, 0, Math.PI * 2);
                let gradient = ctx.createRadialGradient(ball.x - ball.radius/3, ball.y - ball.radius/3, ball.radius/10, ball.x, ball.y, ball.radius);
                gradient.addColorStop(0, THEME.playerColor); 
                gradient.addColorStop(1, "#c0392b");
                ctx.fillStyle = gradient;
                ctx.fill();
                
                ctx.shadowBlur = 0;
                ctx.beginPath();
                ctx.arc(ball.x - ball.radius/3, ball.y - ball.radius/3, ball.radius/4, 0, Math.PI * 2);
                ctx.fillStyle = "rgba(255,255,255,0.4)";
                ctx.fill();
            }
        }

        function gameLoop(time) {
            let dt = time - lastTime;
            lastTime = time;

            update(dt);
            draw();

            if (isPlaying || !uiLayer.classList.contains('hidden')) {
                animationId = requestAnimationFrame(gameLoop);
            }
        }

        // --- äº‹ä»¶ç›£è½ ---
        function resizeCanvas() {
            const container = document.getElementById('game-container');
            const margin = 30; 
            
            let w = window.innerWidth - margin;
            let h = window.innerHeight - margin;

            if (w > 600) {
                let size = Math.min(h, 600); 
                w = size;
                h = size;
            } else {
                if (h > 900) h = 900;
            }

            canvas.width = w;
            canvas.height = h;
            container.style.width = w + 'px';
            container.style.height = h + 'px';
        }

        window.addEventListener('resize', () => {
        });

        // ä¿®æ­£å¾Œçš„é™€èºå„€æ§åˆ¶ (æ”¯æ´æ©«å‘/å¹³æ¿)
        function handleOrientation(event) {
            let x = event.gamma; // å·¦/å³å‚¾æ–œ (ç›´å‘æ™‚)
            let y = event.beta;  // å‰/å¾Œå‚¾æ–œ (ç›´å‘æ™‚)
            
            // å–å¾—è¢å¹•æ—‹è½‰è§’åº¦ (ç›¸å®¹æ€§è™•ç†)
            let angle = 0;
            if (window.screen && window.screen.orientation) {
                angle = window.screen.orientation.angle;
            } else if (typeof window.orientation !== 'undefined') {
                angle = window.orientation;
            }

            let inputX = 0;
            let inputY = 0;

            // æ ¹æ“šè§’åº¦ä¿®æ­£åº§æ¨™è»¸
            if (angle === 90) {
                // æ©«å‘ (Home éµåœ¨å³ / é¡é ­åœ¨å·¦)
                inputX = y;
                inputY = -x;
            } else if (angle === -90 || angle === 270) {
                // æ©«å‘ (Home éµåœ¨å·¦ / é¡é ­åœ¨å³)
                inputX = -y;
                inputY = x;
            } else if (angle === 180) {
                // å€’ç½®
                inputX = -x;
                inputY = -y;
            } else {
                // ç›´å‘ (é è¨­)
                inputX = x;
                inputY = y;
            }

            // ä¿®æ”¹ï¼šé™ä½åˆ¤å®šé–¾å€¼ï¼Œè®“æ“æ§æ›´éˆæ•
            const maxTilt = 30; // åªè¦å‚¾æ–œ 30 åº¦å°±èƒ½é”åˆ°æœ€å¤§é€Ÿåº¦
            
            if (inputX > maxTilt) inputX = maxTilt; 
            if (inputX < -maxTilt) inputX = -maxTilt;
            if (inputY > maxTilt) inputY = maxTilt; 
            if (inputY < -maxTilt) inputY = -maxTilt;
            
            input.x = inputX / maxTilt;
            input.y = inputY / maxTilt;
        }

        window.addEventListener('keydown', (e) => {
            switch(e.key) {
                case 'ArrowUp': input.y = -CONFIG.keyboardForce; break;
                case 'ArrowDown': input.y = CONFIG.keyboardForce; break;
                case 'ArrowLeft': input.x = -CONFIG.keyboardForce; break;
                case 'ArrowRight': input.x = CONFIG.keyboardForce; break;
            }
        });
        window.addEventListener('keyup', (e) => {
            if (['ArrowUp', 'ArrowDown'].includes(e.key)) input.y = 0;
            if (['ArrowLeft', 'ArrowRight'].includes(e.key)) input.x = 0;
        });

        canvas.addEventListener('mousemove', (e) => {
            if (!isPlaying) return;
            const rect = canvas.getBoundingClientRect();
            const centerX = rect.width / 2;
            const centerY = rect.height / 2;
            const mouseX = e.clientX - rect.left;
            const mouseY = e.clientY - rect.top;
            const sensitivity = 0.8; 
            let x = (mouseX - centerX) / (centerX * sensitivity);
            let y = (mouseY - centerY) / (centerY * sensitivity);
            input.x = Math.max(-1, Math.min(1, x));
            input.y = Math.max(-1, Math.min(1, y));
        });

        canvas.addEventListener('mouseleave', () => {
            input.x = 0; input.y = 0;
        });

        document.getElementById('start-btn').addEventListener('click', async () => {
            if (typeof DeviceOrientationEvent !== 'undefined' && typeof DeviceOrientationEvent.requestPermission === 'function') {
                try {
                    const permissionState = await DeviceOrientationEvent.requestPermission();
                    if (permissionState === 'granted') {
                        window.addEventListener('deviceorientation', handleOrientation);
                        startGameFlow();
                    } else {
                        alert("è«‹å…è¨±æ„Ÿæ¸¬å™¨æ¬Šé™ä»¥é«”é©—å®Œæ•´éŠæˆ²ã€‚");
                        startGameFlow();
                    }
                } catch (error) {
                    startGameFlow(); 
                }
            } else {
                window.addEventListener('deviceorientation', handleOrientation);
                startGameFlow();
            }
        });

        function startGameFlow() {
            uiLayer.classList.add('hidden');
            uiLayer.style.backgroundImage = "none";
            uiLayer.style.backgroundColor = "transparent";
            
            // é‡è¦ï¼šéŠæˆ²é–‹å§‹å‰ï¼Œç¢ºä¿æ¨™é¡Œæ˜¯éŠæˆ²æ¨™é¡Œï¼ˆå¦‚æœå¾å‹åˆ©ç•«é¢é‡ä¾†ï¼‰
            resetStartScreen();

            initGame();
        }

        loadAssets(); 
        resizeCanvas();

    </script>
</body>
</html>
