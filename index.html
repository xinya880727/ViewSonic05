<!DOCTYPE html>
<html lang="zh-Hant">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Ëø∑ÂÆÆÈÄÉËÑ´ - Ëá™Ë®ÇÂèÉÊï∏Áâà</title>
    
    <!-- ÂºïÂÖ•Â§ñÈÉ®Ë®≠ÂÆöÊ™î -->
    <script src="game_config.js"></script>

    <style>
        * {
            box-sizing: border-box;
            touch-action: none;
        }

        body {
            margin: 0;
            padding: 0;
            background-color: #1a1a1a;
            color: #ecf0f1;
            font-family: 'Segoe UI', 'Microsoft JhengHei', sans-serif;
            overflow: hidden;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            height: 100vh;
            background-image: radial-gradient(circle at center, #2c3e50 0%, #000000 100%);
            background-size: cover;
            background-position: center;
        }

        #game-container {
            position: relative;
            border-radius: 12px;
            overflow: hidden;
            background: transparent;
            z-index: 1; 
        }

        canvas {
            display: block;
            cursor: crosshair;
        }

        /* UI Ë¶ÜËìãÂ±§ */
        #ui-layer {
            position: fixed;
            top: 0;
            left: 0;
            width: 100vw;
            height: 100vh;
            background: transparent;
            background-size: cover;
            background-position: center;
            
            /* ‰ΩøÁî® Flexbox Â∞áÂÖßÂÆπÁΩÆ‰∏≠ */
            display: flex;
            align-items: center;
            justify-content: center;
            
            z-index: 999;
            padding: 0; 
            transition: background-color 0.5s ease, opacity 0.3s ease;
            pointer-events: auto;
        }

        #ui-layer.hidden {
            opacity: 0;
            pointer-events: none;
        }

        /* ÂÖßÂÆπÂÆπÂô®ÔºöÈÄèÊòé‰∏îÈüøÊáâÂºèÁ∏ÆÊîæ */
        #menu-container {
            display: flex;
            flex-direction: column; 
            align-items: center;    
            justify-content: center;
            
            gap: clamp(10px, 3vh, 30px);
            width: 85%;
            max-width: 500px;
            padding: 20px;
            background: transparent; 
            box-shadow: none;
            backdrop-filter: none;
        }

        h1 {
            font-size: clamp(2.5rem, 10vw, 4rem);
            color: #f1c40f;
            text-transform: uppercase;
            letter-spacing: 3px;
            text-shadow: 0 0 10px rgba(241, 196, 15, 0.5);
            margin: 0;
            text-align: center;
            white-space: nowrap; 
        }

        p {
            font-size: clamp(1rem, 4vw, 1.3rem);
            line-height: 1.6;
            color: #bdc3c7;
            text-shadow: 1px 1px 2px rgba(0,0,0,0.8);
            margin: 0;
            text-align: center;
            white-space: normal;
            word-wrap: break-word;
            width: 100%;
        }

        button {
            background: linear-gradient(135deg, #e74c3c 0%, #c0392b 100%);
            color: white;
            border: none;
            padding: clamp(10px, 2vh, 15px) clamp(30px, 5vw, 50px);
            font-size: clamp(1.1rem, 4vw, 1.5rem);
            border-radius: 8px;
            cursor: pointer;
            box-shadow: 0 5px 15px rgba(192, 57, 43, 0.4);
            transition: all 0.2s ease;
            font-weight: bold;
            letter-spacing: 1px;
            text-transform: uppercase;
            white-space: nowrap;
            margin: 0;
        }

        button:hover {
            transform: translateY(-2px);
            filter: brightness(1.1);
        }

        button:active {
            transform: translateY(2px);
            filter: brightness(0.9);
        }

        #info-bar {
            position: fixed;
            top: 20px;
            left: 20px;
            color: rgba(255, 255, 255, 0.9);
            font-family: monospace;
            font-size: 18px;
            z-index: 100;
            pointer-events: none;
            background: rgba(0, 0, 0, 0.3);
            padding: 8px 15px;
            border-radius: 4px;
            border: 1px solid rgba(255,255,255,0.1);
        }

        #debug {
            position: absolute;
            bottom: 5px;
            left: 5px;
            font-size: 10px;
            color: #555;
            pointer-events: none;
        }
    </style>
</head>
<body>

    <div id="info-bar">TIME: <span id="time-display">0.0</span>s</div>

    <!-- UI Layer -->
    <div id="ui-layer">
        <!-- ÂÆπÂô®ÔºöÈò≤Ê≠¢Ë∑ëÁâà -->
        <div id="menu-container">
            <h1 id="game-title">Ëø∑ÂÆÆÈÄÉËÑ´</h1>
            <p id="ui-message">...</p>
            <button id="start-btn">...</button>
        </div>
    </div>

    <div id="game-container">
        <canvas id="mazeCanvas"></canvas>
        <div id="debug"></div>
    </div>

    <script>
        // ==========================================
        //        üöÄ ÈÅäÊà≤Ê†∏ÂøÉÈÇèËºØ
        // ==========================================

        // --- 1. Ë®≠ÂÆöÊ™îËÆÄÂèñ ---
        let currentConfig;
        const DEFAULT_CONFIG = {
            scale: { player: 0.7, goal: 0.8 },
            physics: { cellSize: 60, ballRadiusRatio: 0.35, friction: 0.94, acceleration: 0.6, maxSpeed: 6, keyboardForce: 1.5 },
            assets: { gameBg: "", startScreenBg: "", endScreenBg: "", player: "", goal: "" },
            style: { wallColor: "#7f8c8d", wallGlow: true, wallThickness: 4, playerColor: "#e74c3c", goalColor: "#2ecc71" },
            text: { gameTitle: "Ëø∑ÂÆÆÈÄÉËÑ´", winTitle: "ÈÄÉËÑ´ÊàêÂäüÔºÅ", startMessage: "...", startButton: "ÈñãÂßã", winMessage: "ÂãùÂà©ÔºÅ", nextLevelButton: "ÈáçË©¶" },
            textStyle: {
                title: { color: "#f1c40f", size: "clamp(2.5rem, 10vw, 4rem)", shadow: "0 0 10px rgba(241, 196, 15, 0.5)" },
                winTitle: { color: "#2ecc71", size: "clamp(2.5rem, 10vw, 4rem)", shadow: "0 0 20px rgba(46, 204, 113, 0.8)" },
                message: { color: "#bdc3c7", size: "clamp(1rem, 4vw, 1.3rem)", shadow: "1px 1px 2px rgba(0,0,0,0.8)" },
                winMessage: { color: "#ffffff", size: "clamp(1rem, 4vw, 1.3rem)", shadow: "0 0 10px rgba(255, 255, 255, 0.8)" },
                button: { 
                    color: "#ffffff", 
                    bgColor: "linear-gradient(135deg, #e74c3c 0%, #c0392b 100%)",
                    size: "clamp(1.1rem, 4vw, 1.5rem)", 
                    shadow: "0 5px 15px rgba(192, 57, 43, 0.4)" 
                }
            }
        };

        if (typeof window.GAME_CONFIG !== 'undefined') {
            currentConfig = window.GAME_CONFIG;
            if (!currentConfig.textStyle) currentConfig.textStyle = JSON.parse(JSON.stringify(DEFAULT_CONFIG.textStyle));
            if (!currentConfig.text.winTitle) currentConfig.text.winTitle = DEFAULT_CONFIG.text.winTitle;
            ['title', 'winTitle', 'message', 'winMessage', 'button'].forEach(key => {
                if (!currentConfig.textStyle[key]) currentConfig.textStyle[key] = DEFAULT_CONFIG.textStyle[key];
            });
        } else {
            console.warn("Using Default Config");
            currentConfig = DEFAULT_CONFIG;
        }

        const THEME = currentConfig.assets;
        Object.assign(THEME, currentConfig.style);
        Object.assign(THEME, currentConfig.text);
        const CONFIG = currentConfig.physics;
        const SCALE = currentConfig.scale;
        const TEXT_STYLE = currentConfig.textStyle;

        // --- 2. ÊáâÁî®Ë®≠ÂÆöÂà∞‰ªãÈù¢ ---
        
        const titleEl = document.getElementById('game-title');
        const msgEl = document.getElementById('ui-message');
        const btnEl = document.getElementById('start-btn');

        function resetStartScreen() {
            titleEl.innerText = THEME.gameTitle;
            msgEl.innerHTML = THEME.startMessage;
            btnEl.innerText = THEME.startButton;
            applyStyle(titleEl, TEXT_STYLE.title);
            applyStyle(msgEl, TEXT_STYLE.message);
            applyStyle(btnEl, TEXT_STYLE.button, true);
        }

        function applyStyle(element, styleObj, isButton = false) {
            if (!element || !styleObj) return;
            if (styleObj.color) element.style.color = styleObj.color;
            if (styleObj.size) element.style.fontSize = styleObj.size;
            if (styleObj.bgColor) element.style.background = styleObj.bgColor;
            if (styleObj.shadow) {
                if (isButton) element.style.boxShadow = styleObj.shadow;
                else element.style.textShadow = styleObj.shadow;
            }
            element.style.position = ""; 
            element.style.top = "";
            element.style.bottom = "";
            element.style.left = "";
            element.style.right = "";
            element.style.transform = "";
        }

        resetStartScreen();

        // --- ËÆäÊï∏ÂÆ£Âëä ---
        const canvas = document.getElementById('mazeCanvas');
        const ctx = canvas.getContext('2d');
        const uiLayer = document.getElementById('ui-layer');
        const timeDisplay = document.getElementById('time-display');

        let mazeState = {};
        let cols, rows;
        let ball = { x: 0, y: 0, vx: 0, vy: 0, radius: 0 };
        let goal = { col: 0, row: 0 };
        let animationId;
        let lastTime = 0;
        let timer = 0;
        let isPlaying = false;
        let input = { x: 0, y: 0 };

        // --- ÂúñÁâáËºâÂÖ•Á≥ªÁµ± ---
        const sprites = {
            bg: new Image(), startBg: new Image(), endBg: new Image(), player: new Image(), goal: new Image()
        };
        let assetsLoaded = { bg: false, startBg: false, endBg: false, player: false, goal: false };

        function loadAssets() {
            if (THEME.gameBg) document.body.style.backgroundImage = `url('${THEME.gameBg}')`;
            if (THEME.startScreenBg) {
                sprites.startBg.src = THEME.startScreenBg;
                sprites.startBg.onload = () => {
                    assetsLoaded.startBg = true;
                    if(!isPlaying && !uiLayer.classList.contains('hidden')) {
                        uiLayer.style.backgroundImage = `url('${THEME.startScreenBg}')`;
                    }
                };
            }
            if (THEME.endScreenBg) { sprites.endBg.src = THEME.endScreenBg; sprites.endBg.onload = () => assetsLoaded.endBg = true; }
            if (THEME.player) { sprites.player.src = THEME.player; sprites.player.onload = () => assetsLoaded.player = true; }
            if (THEME.goal) { sprites.goal.src = THEME.goal; sprites.goal.onload = () => assetsLoaded.goal = true; }
        }

        // --- ÂàùÂßãÂåñ ---
        function initGame() {
            resizeCanvas();
            uiLayer.style.backgroundImage = "none";
            uiLayer.style.backgroundColor = "transparent";

            const mazePadding = 25; 
            const availableWidth = canvas.width - (mazePadding * 2);
            const availableHeight = canvas.height - (mazePadding * 2);

            let adaptiveCellSize = CONFIG.cellSize;
            const minColsForMobile = 9; 
            const calculatedCols = Math.floor(availableWidth / adaptiveCellSize);

            if (calculatedCols < minColsForMobile) {
                adaptiveCellSize = Math.floor(availableWidth / minColsForMobile);
                adaptiveCellSize = Math.max(30, adaptiveCellSize); 
            }

            cols = Math.floor(availableWidth / adaptiveCellSize);
            rows = Math.floor(availableHeight / adaptiveCellSize);
            
            if (cols < 3) cols = 3;
            if (rows < 3) rows = 3;

            const effectiveCellWidth = availableWidth / cols;
            const effectiveCellHeight = availableHeight / rows;
            const finalSize = Math.min(effectiveCellWidth, effectiveCellHeight);
            
            const offsetX = (canvas.width - cols * finalSize) / 2;
            const offsetY = (canvas.height - rows * finalSize) / 2;

            // Ë®àÁÆóÁ∏ÆÊîæÊØî‰æã (ÂØ¶Èöõ/È†êË®≠)
            const speedScale = finalSize / CONFIG.cellSize;

            mazeState = {
                cols: cols, rows: rows, cellSize: finalSize, offsetX: offsetX, offsetY: offsetY, grid: [],
                speedScale: speedScale
            };

            generateMaze();
            spawnBallAndGoal();
            
            timer = 0;
            ball.vx = 0;
            ball.vy = 0;
            isPlaying = true;
            lastTime = performance.now();
            
            if (animationId) cancelAnimationFrame(animationId);
            gameLoop(lastTime);
        }

        // --- Ëø∑ÂÆÆÁîüÊàê ---
        function generateMaze() {
            mazeState.grid = [];
            for (let r = 0; r < rows; r++) {
                let row = [];
                for (let c = 0; c < cols; c++) {
                    row.push({ c: c, r: r, visited: false, walls: { top: true, right: true, bottom: true, left: true } });
                }
                mazeState.grid.push(row);
            }
            let stack = [];
            let current = mazeState.grid[0][0];
            current.visited = true;
            stack.push(current);
            while (stack.length > 0) {
                let next = checkNeighbors(current);
                if (next) {
                    next.visited = true; stack.push(current); removeWalls(current, next); current = next;
                } else {
                    current = stack.pop();
                }
            }
        }

        function checkNeighbors(cell) {
            let neighbors = [];
            let top = (cell.r > 0) ? mazeState.grid[cell.r - 1][cell.c] : undefined;
            let right = (cell.c < cols - 1) ? mazeState.grid[cell.r][cell.c + 1] : undefined;
            let bottom = (cell.r < rows - 1) ? mazeState.grid[cell.r + 1][cell.c] : undefined;
            let left = (cell.c > 0) ? mazeState.grid[cell.r][cell.c - 1] : undefined;
            if (top && !top.visited) neighbors.push(top);
            if (right && !right.visited) neighbors.push(right);
            if (bottom && !bottom.visited) neighbors.push(bottom);
            if (left && !left.visited) neighbors.push(left);
            if (neighbors.length > 0) return neighbors[Math.floor(Math.random() * neighbors.length)];
            return undefined;
        }

        function removeWalls(a, b) {
            let x = a.c - b.c;
            if (x === 1) { a.walls.left = false; b.walls.right = false; }
            else if (x === -1) { a.walls.right = false; b.walls.left = false; }
            let y = a.r - b.r;
            if (y === 1) { a.walls.top = false; b.walls.bottom = false; }
            else if (y === -1) { a.walls.bottom = false; b.walls.top = false; }
        }

        function spawnBallAndGoal() {
            let size = mazeState.cellSize;
            ball.radius = size * CONFIG.ballRadiusRatio;
            ball.x = mazeState.offsetX + size * 0.5;
            ball.y = mazeState.offsetY + size * 0.5;
            goal.col = cols - 1;
            goal.row = rows - 1;
        }

        // --- Áâ©ÁêÜÊõ¥Êñ∞ ---
        function update(dt) {
            if (!isPlaying) return;
            timer += dt / 1000;
            timeDisplay.innerText = timer.toFixed(1);

            const effectiveSpeed = CONFIG.maxSpeed * (mazeState.speedScale || 1);

            ball.vx = input.x * effectiveSpeed;
            ball.vy = input.y * effectiveSpeed;

            let nextX = ball.x + ball.vx;
            let nextY = ball.y + ball.vy;
            let size = mazeState.cellSize;
            let ox = mazeState.offsetX;
            let oy = mazeState.offsetY;

            let currentC = Math.floor((ball.x - ox) / size);
            let currentR = Math.floor((ball.y - oy) / size);
            
            currentC = Math.max(0, Math.min(cols - 1, currentC));
            currentR = Math.max(0, Math.min(rows - 1, currentR));

            let cell = mazeState.grid[currentR][currentC];

            if (cell.walls.left && nextX - ball.radius < ox + currentC * size) {
                nextX = ox + currentC * size + ball.radius;
            } else if (cell.walls.right && nextX + ball.radius > ox + (currentC + 1) * size) {
                nextX = ox + (currentC + 1) * size - ball.radius;
            }
            ball.x = nextX;

            if (cell.walls.top && nextY - ball.radius < oy + currentR * size) {
                nextY = oy + currentR * size + ball.radius;
            } else if (cell.walls.bottom && nextY + ball.radius > oy + (currentR + 1) * size) {
                nextY = oy + (currentR + 1) * size - ball.radius;
            }
            ball.y = nextY;

            let goalX = ox + goal.col * size + size * 0.5;
            let goalY = oy + goal.row * size + size * 0.5;
            let dist = Math.sqrt((ball.x - goalX)**2 + (ball.y - goalY)**2);

            if (dist < size * 0.4) winLevel();
        }

        function winLevel() {
            isPlaying = false;
            let msg = THEME.winMessage.replace('{time}', timer.toFixed(2));
            msgEl.innerHTML = msg;
            btnEl.innerText = THEME.nextLevelButton;
            uiLayer.classList.remove('hidden');
            uiLayer.style.backgroundColor = "rgba(0, 0, 0, 0.85)";
            if (THEME.winTitle) titleEl.innerText = THEME.winTitle;
            if (TEXT_STYLE.winTitle) applyStyle(titleEl, TEXT_STYLE.winTitle);
            if (TEXT_STYLE.winMessage) applyStyle(msgEl, TEXT_STYLE.winMessage);
            if (assetsLoaded.endBg) uiLayer.style.backgroundImage = `url('${THEME.endScreenBg}')`;
        }

        function draw() {
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            let size = mazeState.cellSize;
            let ox = mazeState.offsetX;
            let oy = mazeState.offsetY;
            let goalX = ox + goal.col * size + size * 0.5;
            let goalY = oy + goal.row * size + size * 0.5;

            if (assetsLoaded.goal) {
                let goalSize = size * SCALE.goal;
                ctx.drawImage(sprites.goal, goalX - goalSize/2, goalY - goalSize/2, goalSize, goalSize);
            } else {
                ctx.shadowBlur = 20; ctx.shadowColor = THEME.goalColor;
                ctx.beginPath(); ctx.arc(goalX, goalY, ball.radius * 1.2, 0, Math.PI * 2); ctx.fillStyle = THEME.goalColor; ctx.fill();
                ctx.shadowBlur = 0; ctx.fillStyle = "#000"; ctx.beginPath(); ctx.arc(goalX, goalY, ball.radius * 0.8, 0, Math.PI * 2); ctx.fill();
                ctx.strokeStyle = THEME.goalColor; ctx.lineWidth = 2; ctx.beginPath();
                for(let i=0; i<3; i++) ctx.arc(goalX, goalY, ball.radius * (0.2 + i*0.2), 0 + timer*2, Math.PI + timer*2);
                ctx.stroke();
            }

            ctx.strokeStyle = THEME.wallColor; 
            ctx.lineCap = "round";
            
            // [ÈóúÈçµ‰øÆÊ≠£] ÁâÜÂ£ÅÁ≤óÁ¥∞Èö®Ê†ºÂ≠êÂ§ßÂ∞èËá™ÂãïÁ∏ÆÊîæ
            // ÈÅøÂÖçÂú®Â∞èÊ†ºÂ≠ê(ÊâãÊ©ü)ÊôÇÁâÜÂ£ÅÁúãËµ∑‰æÜÂ§™Á≤ó
            const scaleFactor = size / CONFIG.cellSize;
            ctx.lineWidth = Math.max(1, THEME.wallThickness * scaleFactor);

            if (THEME.wallGlow) { ctx.shadowBlur = 10; ctx.shadowColor = THEME.wallColor; } else { ctx.shadowBlur = 0; }
            ctx.beginPath();
            for (let r = 0; r < rows; r++) {
                for (let c = 0; c < cols; c++) {
                    let cell = mazeState.grid[r][c];
                    let x = ox + c * size; let y = oy + r * size;
                    if (cell.walls.top) { ctx.moveTo(x, y); ctx.lineTo(x + size, y); }
                    if (cell.walls.right) { ctx.moveTo(x + size, y); ctx.lineTo(x + size, y + size); }
                    if (cell.walls.bottom) { ctx.moveTo(x + size, y + size); ctx.lineTo(x, y + size); }
                    if (cell.walls.left) { ctx.moveTo(x, y + size); ctx.lineTo(x, y); }
                }
            }
            ctx.stroke(); ctx.shadowBlur = 0; 

            if (assetsLoaded.player) {
                let pSize = size * SCALE.player; 
                ctx.drawImage(sprites.player, ball.x - pSize/2, ball.y - pSize/2, pSize, pSize);
            } else {
                ctx.shadowBlur = 15; ctx.shadowColor = THEME.playerColor;
                ctx.beginPath(); ctx.arc(ball.x, ball.y, ball.radius, 0, Math.PI * 2);
                let gradient = ctx.createRadialGradient(ball.x - ball.radius/3, ball.y - ball.radius/3, ball.radius/10, ball.x, ball.y, ball.radius);
                gradient.addColorStop(0, THEME.playerColor); gradient.addColorStop(1, "#c0392b");
                ctx.fillStyle = gradient; ctx.fill();
                ctx.shadowBlur = 0; ctx.beginPath(); ctx.arc(ball.x - ball.radius/3, ball.y - ball.radius/3, ball.radius/4, 0, Math.PI * 2);
                ctx.fillStyle = "rgba(255,255,255,0.4)"; ctx.fill();
            }
        }

        function gameLoop(time) {
            let dt = time - lastTime;
            lastTime = time;
            update(dt);
            draw();
            if (isPlaying || !uiLayer.classList.contains('hidden')) {
                animationId = requestAnimationFrame(gameLoop);
            }
        }

        function resizeCanvas() {
            const container = document.getElementById('game-container');
            const margin = 30; 
            let w = window.innerWidth - margin; let h = window.innerHeight - margin;
            if (w > 600) { let size = Math.min(h, 600); w = size; h = size; } 
            else { if (h > 900) h = 900; }
            canvas.width = w; canvas.height = h;
            container.style.width = w + 'px'; container.style.height = h + 'px';
        }

        window.addEventListener('resize', () => {});

        function handleOrientation(event) {
            let rawBeta = event.beta;  
            let rawGamma = event.gamma; 
            
            if (rawBeta === null || rawGamma === null) return;

            let x, y;

            if (window.innerWidth > window.innerHeight) {
                x = rawBeta; 
                y = -rawGamma; 
            } else {
                x = rawGamma;
                y = rawBeta;
            }

            const maxTilt = 30; 
            
            if (x > maxTilt) x = maxTilt; 
            if (x < -maxTilt) x = -maxTilt;
            if (y > maxTilt) y = maxTilt; 
            if (y < -maxTilt) y = -maxTilt;
            
            input.x = x / maxTilt;
            input.y = y / maxTilt;
        }

        window.addEventListener('keydown', (e) => {
            switch(e.key) {
                case 'ArrowUp': input.y = -1; break;
                case 'ArrowDown': input.y = 1; break;
                case 'ArrowLeft': input.x = -1; break;
                case 'ArrowRight': input.x = 1; break;
            }
        });
        window.addEventListener('keyup', (e) => {
            if (['ArrowUp', 'ArrowDown'].includes(e.key)) input.y = 0;
            if (['ArrowLeft', 'ArrowRight'].includes(e.key)) input.x = 0;
        });

        canvas.addEventListener('mousemove', (e) => {
            if (!isPlaying) return;
            const rect = canvas.getBoundingClientRect();
            const centerX = rect.width / 2;
            const centerY = rect.height / 2;
            const mouseX = e.clientX - rect.left;
            const mouseY = e.clientY - rect.top;
            const sensitivity = 0.8; 
            let x = (mouseX - centerX) / (centerX * sensitivity);
            let y = (mouseY - centerY) / (centerY * sensitivity);
            input.x = Math.max(-1, Math.min(1, x));
            input.y = Math.max(-1, Math.min(1, y));
        });

        canvas.addEventListener('mouseleave', () => { input.x = 0; input.y = 0; });

        document.getElementById('start-btn').addEventListener('click', async () => {
            if (typeof DeviceOrientationEvent !== 'undefined' && typeof DeviceOrientationEvent.requestPermission === 'function') {
                try {
                    const permissionState = await DeviceOrientationEvent.requestPermission();
                    if (permissionState === 'granted') {
                        window.addEventListener('deviceorientation', handleOrientation);
                        startGameFlow();
                    } else {
                        alert("Ë´ãÂÖÅË®±ÊÑüÊ∏¨Âô®Ê¨äÈôê‰ª•È´îÈ©óÂÆåÊï¥ÈÅäÊà≤„ÄÇ");
                        startGameFlow();
                    }
                } catch (error) {
                    startGameFlow(); 
                }
            } else {
                window.addEventListener('deviceorientation', handleOrientation);
                startGameFlow();
            }
        });

        function startGameFlow() {
            uiLayer.classList.add('hidden');
            uiLayer.style.backgroundImage = "none";
            uiLayer.style.backgroundColor = "transparent";
            resetStartScreen();
            initGame();
        }

        loadAssets(); 
        resizeCanvas();

    </script>
</body>
</html>
